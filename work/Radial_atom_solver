#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Mar  2 09:27:19 2020

@author: H.R.A. ten Eikelder
program: OF-DFT radial atom solver using the FEniCS Python module. 
Description: This program takes as input the DFT equations and gives 
            as output the electron density of the material. In this case 
            the material is one atom. The atom will be simulated on the left 
            boundary and the 'infite space' will be simulated on the right 
            boundary. 
"""

from __future__ import print_function
from fenics import *
from matplotlib import pyplot as plt
"""------------------------------------------------------------------------- 
                    Creating the mesh 
-------------------------------------------------------------------------""" 
# Create mesh and define function space
mesh = UnitIntervalMesh(5)
V = FunctionSpace(mesh, 'P', 1)

"""------------------------------------------------------------------------- 
                    Creating and defining the boundary conditions
-------------------------------------------------------------------------"""
#Defining the tolerance on the boundaries 
tol = 1E-14

#Defining the left boundary
def boundary_L(x, on_boundary):
    return on_boundary and near(x[0], 0, tol)

#Defining the right boundary
def boundary_R(x, on_boundary):
    return on_boundary and near(x[0], 1, tol)

#defining expression on left boundary
u_L = Expression('1 + 2*x[1]*x[1]', degree=2) 

#Define left boundary
bc_L = DirichletBC(V, u_L, boundary_L) 

#defining expression on right boundary
u_R = Expression('2 + 2*x[1]*x[1]', degree=2) 

#Define right boundary
bc_R = DirichletBC(V, u_R, boundary_R) 

"""-------------------------------------------------------------------------
                    Defining and solving the variational problem
 -------------------------------------------------------------------------"""
# Define variational problem
u = TrialFunction(V)
v = TestFunction(V)
f = Constant(-6)
a = dot(grad(u), grad(v))*dx
g = Expression('-4*x[1]', degree=1) 
L = f*v*dx 

# Compute solution
n = Function(V)
solve(a == L, u, bcs)

"""-------------------------------------------------------------------------
                    Saving VTKfile for post processing in ParaView
-------------------------------------------------------------------------"""
# Save solution to file in VTK format
vtkfile = File('work/radial_atom_solver.pvd')
vtkfile << n

"""-------------------------------------------------------------------------
                    Computing the error 
 -------------------------------------------------------------------------"""
# Compute error in L2 norm
error_L2 = errornorm(u_L, u, 'L2')

# Compute maximum error at vertices
vertex_values_u_D = u_L.compute_vertex_values(mesh)
vertex_values_u = u.compute_vertex_values(mesh)

import numpy as np
error_max = np.max(np.abs(vertex_values_u_D - vertex_values_u))

# Print errors
print('error_L2  =', error_L2)
print('error_max =', error_max)

"""-------------------------------------------------------------------------
                    Plot solution and mesh
-------------------------------------------------------------------------"""
plt.figure()
plot(n)
plot(mesh)

# show the plots
plt.show()